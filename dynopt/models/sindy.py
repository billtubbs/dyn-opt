"""
Implementation of SINDy algorithm based on code by Steven L.
Brunton.  See Paper, 'Discovering Governing Equations from Data:
Sparse Identification of Nonlinear Dynamical Systems' by S. L.
Brunton, J. L. Proctor, and J. N. Kutz.
Original code available from: https://www.eigensteve.com
"""
import numpy as np


def polynomial_features(y_in, order=3):
    """Calculate polynomial terms up to given order for
    all data points in y_in.  This function is similar
    to sklearn.preprocessing.PolynomialFeatures method
    but considerably faster.

    Args:
        y_in (array): m x n array containing m data points 
            for n input variables.
        poly_order (int): Order of polynomial to generate
            terms for (1, 2 or 3).
    
    Returns:
        y_out (array): 
    """
    n = y_in.shape[1]
    y_out_cols = []

    # Poly order 0
    y_out_cols.append(np.ones((len(y_in), 1)))

    # Poly order 1
    y_out_cols.append(y_in)

    # Poly order 2
    if order >= 2:
        for i in range(n):
            y_out_cols.append(y_in[:, i:] * y_in[:, i].reshape(-1, 1))

    # Poly order 3
    if order == 3:
        # Use poly order 2 results
        results = y_out_cols[-n:]
        for j in range(0, n):
            for result in results[j:]:
                y_out_cols.append(result * y_in[:, j].reshape(-1, 1))

    if order > 3:
        raise NotImplementedError("poly_order up to 3 implemented")

    return np.hstack(y_out_cols)


def sparsify_dynamics_lstsq(theta, y, lamb, max_iter=20):
    """SINDy algorithm to find sparse polynomial model
    of dynamics using ordinary least-squares.
    """

    n_out = y.shape[1]
    # Initial guess: Least-squares
    xi = np.linalg.lstsq(theta, y, rcond=None)[0]

    for _ in range(max_iter):
        # Find large coefficients above threshold
        big_coefs = np.abs(xi) >= lamb

        # Set small coefficients to zero
        xi[~big_coefs] = 0

        # Check that not all coefficients are zero for any output
        if np.any(np.count_nonzero(big_coefs, axis=0) == 0):
            raise ValueError(
                "Sparsity parameter is too big ({}) and eliminated all "
                "coefficients".format(lamb)
            )

        # Regress dynamics onto remaining terms to find sparse xi
        for i in range(n_out):  # n is state dimension
            coefs_i = big_coefs[:, i]
            xi[coefs_i, i] = np.linalg.lstsq(theta[:, coefs_i], y[:, i],
                                             rcond=None)[0]

    return xi


def polynomial_feature_labels(n_vars, order, names=None,
                              vstr='x', psym='**'):
    """Returns a list of strings that represent the
    expressions of all the combinations of polynomial
    terms of a function with n_vars variables.  The list
    is ordered the same way as the features generated by
    the polynomial_features function.

    Args:
        n_vars (int): Number of feature variables.
        poly_order (int): 1, 2 or 3.
        names (list): List of labels for each variable.
            If not specified, ['x0', 'x1', ... etc.]
            will be used.
        vstr (str): If names is not provided, this string is
            used to construct the variable labels (e.g. if
            vstr = 'x', names = ['x0', 'x1', ...]).
        psym (str): How to represent the power
            operator (e.g. '**' or '^').

    Example 1:
    >>> polynomial_feature_labels(2, 2)
    ['1', 'x0', 'x1', 'x0**2', 'x0*x1', 'x1**2']

    Example 2:
    >>> polynomial_feature_labels(2, 3, names=['X1', 'X2'])
    ['1',
     'X1',
     'X2',
     'X1**2',
     'X1*X2',
     'X2**2',
     'X1**3',
     'X1**2*X2',
     'X1*X2**2',
     'X2**3']

    Note, these string 'expressions' can be used to calculate
    the features using pandas.DataFrame.eval().

    Example 3:
    >>> data = pd.DataFrame({'X1': range(5), 'X2': range(5, 10)})
    >>> exps = polynomial_feature_labels(2, 3, names=data.columns)
    >>> data.eval(exps[3])  # 'X1**2'
    0     0
    1     1
    2     4
    3     9
    4    16
    Name: X1, dtype: int64
    """
    if names is None:
        names = [f'{vstr}{i}' for i in range(n_vars)]
    else:
        names = list(names)

    labels = []

    # Poly order 0
    labels.append('1')

    # Poly order 1
    labels = labels + names

    # Poly order 2
    if order >= 2:
        for i in range(n_vars):
            labels = labels + ['*'.join([names[i], names[j]])
                               for j in range(i, n_vars)]

    # Poly order 3
    if order == 3:
        for i in range(n_vars):
            for j in range(i, n_vars):
                labels = labels + ['*'.join([names[i], names[j], names[k]])
                                   for k in range(j, n_vars)]

    if order > 3:
        raise NotImplementedError("poly_order up to 3 implemented")

    for name in names:
        old = f'{name}*{name}*{name}'
        new = f'{name}{psym}3'
        for i, label in enumerate(labels):
            labels[i] = label.replace(old, new)
        old = f'{name}*{name}'
        new = f'{name}{psym}2'
        for i, label in enumerate(labels):
            labels[i] = label.replace(old, new)

    return labels
